<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <link rel="canonical" href="https://pakistanaddress.github.io/html/category/article-2439.htm" />
<title>python并发编程：协程asyncio、多线程threading、多进程multiprocessing - Pakistan Address</title>
<!-- for-mobile-apps -->
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="icon" href="/assets/addons/xcblog/img/pakistanaddress/favicon.ico" type="image/x-icon"/>
<script type="application/x-javascript"> addEventListener("load", function() { setTimeout(hideURLbar, 0); }, false);
		function hideURLbar(){ window.scrollTo(0,1); } </script>
<!-- //for-mobile-apps -->
<link href="/assets/addons/xcblog/css/pakistanaddress/bootstrap.css" rel="stylesheet" type="text/css" media="all" />
<link href="/assets/addons/xcblog/css/pakistanaddress/style.css" rel="stylesheet" type="text/css" media="all" />
<!-- js -->
<script type="text/javascript" src="/assets/addons/xcblog/js/frontend/pakistanaddress/jquery-2.1.4.min.js"></script>
<!-- //js -->
<link href='https://fonts.googleapis.com/css?family=Maven+Pro:400,500,700,900' rel='stylesheet' type='text/css'>
<link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
<!-- start-smoth-scrolling -->
<script type="text/javascript">
	jQuery(document).ready(function($) {
		$(".scroll").click(function(event){		
			event.preventDefault();
			$('html,body').animate({scrollTop:$(this.hash).offset().top},1000);
		});
	});
</script>
<!-- start-smoth-scrolling -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?21f4e50ed805b3a1bd1374e6b345c04a";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body>
    <!-- header -->
	<div class="header" id="ban">
		<div class="container">
			<div class="w3ls_logo">
								<a href="/">Pakistan Address</a>
							</div>
			<div class="header_right">
			<nav class="navbar navbar-default">
				<!-- Brand and toggle get grouped for better mobile display -->
				<div class="navbar-header">
					<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
				</div>

				<!-- Collect the nav links, forms, and other content for toggling -->
				<div class="collapse navbar-collapse nav-wil" id="bs-example-navbar-collapse-1">
					<nav class="link-effect-7" id="link-effect-7">
						<ul class="nav navbar-nav">
														<li><a href="/">首页</a></li>
														<li><a href="/html/category/">文章分类</a></li>
														<li><a href="#">关于</a></li>
							<li><a href="#">联系</a></li>
						</ul>
					</nav>
				</div>
				<!-- /.navbar-collapse -->
			</nav>
			</div>
			<div class="clearfix"> </div>
		</div>
	</div>
<!-- //header -->
    <!-- about -->
    <div class="about">
        <div class="container">
            <h1 style="word-break: break-all;">python并发编程：协程asyncio、多线程threading、多进程multiprocessing</h1>
            <ul>
                <li><a href="/">首页</a><i>|</i></li>
                <li><a href="/html/category/">文章分类</a><i>|</i></li>
                <li>正文</li>
            </ul>
        </div>
    </div>
    <!-- //about -->
    <!-- single -->
    <div class="single">
        <div class="container">
            <div class="col-md-9">
                <div class="wthree_single_grid1">
                      				  				  				<div id="content_views" class="markdown_views prism-atom-one-dark"> <div class="toc"> <h3>python并发编程：协程、多线程、多进程</h3> <ul> <li><a href="#CPUIO_1" rel="nofollow">CPU密集型计算与IO密集型计算</a></li> <li><a href="#_5" rel="nofollow">多线程、多进程与协程的对比</a></li> <li><a href="#_12" rel="nofollow">多线程</a></li> <li> <ul> <li><a href="#_13" rel="nofollow">创建多线程的方法</a></li> <li><a href="#_27" rel="nofollow">多线程实现的生产者-消费者爬虫</a></li> <li><a href="#Lock_75" rel="nofollow">Lock解决线程安全问题</a></li> <li><a href="#ThreadPoolExecutor_96" rel="nofollow">使用线程池ThreadPoolExecutor</a></li> </ul> </li> <li><a href="#_130" rel="nofollow">多进程</a></li> <li> <ul> <li><a href="#multiprocessingthreading_131" rel="nofollow">多进程multiprocessing对比多线程threading</a></li> </ul> </li> <li><a href="#_134" rel="nofollow">协程</a></li> <li> <ul> <li><a href="#_135" rel="nofollow">协程简介</a></li> <li><a href="#_152" rel="nofollow">控制并发</a></li> <li><a href="#await_178" rel="nofollow">await关键字</a></li> <li><a href="#Task_193" rel="nofollow">Task对象</a></li> <li><a href="#Future_294" rel="nofollow">Future对象</a></li> <li><a href="#creak_taskensure_future_355" rel="nofollow">creak_task与ensure_future的异同</a></li> <li><a href="#asynciowaitasyniogather_357" rel="nofollow">asyncio.wait与asynio.gather的异同</a></li> <li><a href="#event_loop_360" rel="nofollow">event loop</a></li> </ul> </li> <li><a href="#_362" rel="nofollow">参考文章</a></li> </ul> </div> <h1><a id="CPUIO_1" rel="nofollow"></a>CPU密集型计算与IO密集型计算</h1> <ul> <li>CPU密集型计算：也叫计算密集型，是指IO在很短的时间内就可以完成，CPU需要大量的计算与处理，特点是CPU占用率高。如：<code>压缩解压缩、加密解密、正则表达式</code></li> <li>IO密集型计算：指的是系统运作的大部分状况是CPU在等I/O（硬盘/内存）的读写操作，CPU占用率较低。如：<code>网络爬虫、读写数据库</code></li> </ul> <h1><a id="_5" rel="nofollow"></a>多线程、多进程与协程的对比</h1> <table> <thead> <tr> <th></th> <th>多进程Process(multiprocessing)</th> <th>多线程Thread(threading)</th> <th>协程Coroutine(asyncio)</th> </tr> </thead> <tbody> <tr> <td>优点</td> <td>可以利用多核CPU并行运算</td> <td>相比进程更轻量级，占用资源少</td> <td>内存开销最少，启动协程数量最多</td> </tr> <tr> <td>缺点</td> <td>占用资源最多，可启动数目比线程少</td> <td>相比进程多线程只能并发执行，不能利用多CPU(GIL)；相比协程启动数目有限制，占用内存资源，有线程切换开销</td> <td>支持的库有限制，代码实现复杂</td> </tr> <tr> <td>适用场景</td> <td>CPU密集型计算</td> <td>IO密集型计算、同时运行的任务数目要求不多</td> <td>IO密集型计算、需要超多任务运行但有现成的库支持的场景</td> </tr> </tbody> </table> <h1><a id="_12" rel="nofollow"></a>多线程</h1> <h2><a id="_13" rel="nofollow"></a>创建多线程的方法</h2> <ol> <li>准备一个函数：</li> </ol> <pre><code class="prism language-python"><span class="token keyword">def</span><span class="token function">my_func</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">:</span> 	do_something<span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span></code></pre> <ol start="2"> <li>创建一个线程：</li> </ol> <pre><code class="prism language-python"><span class="token keyword">import</span> threading t<span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span> my_func<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <ol start="3"> <li>启动线程：<code>t.start()</code></li> <li>等待结束：<code>t.join()</code></li> </ol> <h2><a id="_27" rel="nofollow"></a>多线程实现的生产者-消费者爬虫</h2> <ol> <li>多线程数据通信的queue.Queue</li> </ol> <ul> <li>导入类库：<code>import queue</code></li> <li>创建Queue：<code>q = queue.Queue()</code></li> <li>添加元素：<code>q.put(item)</code></li> <li>获取元素：<code>item = q.get()</code></li> <li>查询元素的多少：<code>q.qsize()</code></li> <li>判断是否为空：<code>q.empty()</code></li> <li>判断是否已满：<code>q.full()</code></li> </ul> <ol start="2"> <li>实现案例代码：</li> </ol> <pre><code class="prism language-python"><span class="token keyword">import</span> threading<span class="token keyword">import</span> requests<span class="token keyword">import</span> queue<span class="token keyword">def</span><span class="token function">do_crawl</span><span class="token punctuation">(</span>url_queue<span class="token punctuation">,</span>html_queue<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">while</span><span class="token boolean">True</span><span class="token punctuation">:</span>         url<span class="token operator">=</span> url_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>         html<span class="token operator">=</span> requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span>         html_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string-interpolation"><span class="token string">f'crawl</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>url<span class="token punctuation">}</span></span><span class="token string">,url_queue.size=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>url_queue<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span><span class="token keyword">def</span><span class="token function">do_parse</span><span class="token punctuation">(</span>html_queue<span class="token punctuation">,</span>fout<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">while</span><span class="token boolean">True</span><span class="token punctuation">:</span>         html<span class="token operator">=</span> html_queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>         results<span class="token operator">=</span> html<span class="token punctuation">.</span>text<span class="token keyword">for</span> result<span class="token keyword">in</span> results<span class="token punctuation">:</span>             fout<span class="token punctuation">.</span>write<span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>threading<span class="token punctuation">.</span>current_thread<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">,</span><span class="token string-interpolation"><span class="token string">f'results.size=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span><span class="token builtin">len</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">,html_queue.size=</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>html_queue<span class="token punctuation">.</span>qsize<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  url_queue<span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span> html_queue<span class="token operator">=</span> queue<span class="token punctuation">.</span>Queue<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> url<span class="token keyword">in</span> url_list<span class="token punctuation">:</span>     url_queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token comment">#启动三个生产者线程</span><span class="token keyword">for</span> idx<span class="token keyword">in</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      t<span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>do_crawl<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>url_queue<span class="token punctuation">,</span>html_queue<span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string-interpolation"><span class="token string">f'crawl</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>idx<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>     t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>  fout<span class="token operator">=</span><span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'test.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">)</span><span class="token comment">#启动两个消费者线程</span><span class="token keyword">for</span> idx<span class="token keyword">in</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     t<span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>do_parse<span class="token punctuation">,</span>args<span class="token operator">=</span><span class="token punctuation">(</span>html_queue<span class="token punctuation">,</span>fout<span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string-interpolation"><span class="token string">f'parse</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>idx<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>     t<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre> <h2><a id="Lock_75" rel="nofollow"></a>Lock解决线程安全问题</h2> <ol> <li>try-finally模式</li> </ol> <pre><code class="prism language-python"><span class="token keyword">import</span> threading lock<span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span> lock<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token comment">#do something</span><span class="token keyword">finally</span><span class="token punctuation">:</span> 	lock<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre> <ol start="2"> <li>with模式</li> </ol> <pre><code class="prism language-python"><span class="token keyword">import</span> threading lock<span class="token operator">=</span> threading<span class="token punctuation">.</span>Lock<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> lock<span class="token punctuation">:</span><span class="token comment">#do something</span></code></pre> <h2><a id="ThreadPoolExecutor_96" rel="nofollow"></a>使用线程池ThreadPoolExecutor</h2> <ol> <li>使用线程池的好处</li> </ol> <ul> <li>提升性能：减去了大量新建、终止线程的开销，重用了线程资源</li> <li>适用场景：处理突发性大量请求或需要大量线程完成任务，但实际任务处理时间较短</li> <li>防御功能：能有效避免系统因为创建线程过多而导致系统负荷过大相应变慢等问题</li> <li>代码优势：使用线程池的语法比自己新建线程执行线程更加简洁</li> </ul> <ol start="2"> <li>ThreadPoolExecutor的使用方法</li> </ol> <ul> <li>用法一：<code>map函数</code>，较简单，需要注意map的结果和入参是顺序对应的</li> </ul> <pre><code class="prism language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures<span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span>as_completed<span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">as</span> pool<span class="token punctuation">:</span>     results<span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span>crawl<span class="token punctuation">,</span>urls<span class="token punctuation">)</span><span class="token keyword">for</span> result<span class="token keyword">in</span> results<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre> <ul> <li>用法二：<code>future模式</code>，更强大，需要注意如果用as_completed顺序是不定的</li> </ul> <pre><code class="prism language-python"><span class="token keyword">from</span> concurrent<span class="token punctuation">.</span>futures<span class="token keyword">import</span> ThreadPoolExecutor<span class="token punctuation">,</span>as_completed<span class="token keyword">with</span> ThreadPoolExecutor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">as</span> pool<span class="token punctuation">:</span>     futures<span class="token operator">=</span><span class="token punctuation">[</span>pool<span class="token punctuation">.</span>submit<span class="token punctuation">(</span>crawl<span class="token punctuation">,</span>url<span class="token punctuation">)</span><span class="token keyword">for</span> url<span class="token keyword">in</span> urls<span class="token punctuation">]</span><span class="token keyword">for</span> future<span class="token keyword">in</span> futures<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> future<span class="token keyword">in</span> as_completed<span class="token punctuation">(</span>futures<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>future<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <h1><a id="_130" rel="nofollow"></a>多进程</h1> <h2><a id="multiprocessingthreading_131" rel="nofollow"></a>多进程multiprocessing对比多线程threading</h2> <p><img decoding="async" src="http://img.555519.xyz/uploads3/20220818/a2f58a3991da3cbca01d8972cdbe0430.jpg" alt="python并发编程：协程asyncio、多线程threading、多进程multiprocessing"><br /><mark>多进程的使用方法和多线程比较类似，可以参考多线程的代码。</mark></p> <h1><a id="_134" rel="nofollow"></a>协程</h1> <h2><a id="_135" rel="nofollow"></a>协程简介</h2> <ol> <li>协程的核心原理：用一个超级循环（其实就是while true），配合IO多路复用（IO时CPU可以做其他事情）。</li> <li>协程的简单使用：</li> </ol> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token comment">#获取事件循环</span> loop<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#定义协程</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">myfunc</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">await</span> get_url<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token comment">#创建task列表</span> tasks<span class="token operator">=</span><span class="token punctuation">[</span>loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>myfunc<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> url<span class="token keyword">in</span> urls<span class="token punctuation">]</span><span class="token comment">#执行爬虫事件列表</span> loop<span class="token punctuation">.</span>run_until_complete<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>tasks<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <h2><a id="_152" rel="nofollow"></a>控制并发</h2> <ol> <li><code>信号量（Semaphore）</code>是一个同步对象，用于保持在0至指定最大值之间的一个计数值</li> </ol> <ul> <li>当线程完成一次对该semaphore对象的等待（wait）时，该计数值减1</li> <li>当线程完成一次对该semaphore对象的释放（release）时，该计数值加1</li> <li>当计数值为0，则线程等待该semaphore对象不再能成功直至该semaphore对象变成signaled状态</li> <li>semaphore对象的计数值大于0，为signaled状态；计数值等于0，为nonsignaled状态</li> </ul> <ol start="2"> <li>使用方式</li> </ol> <ul> <li>用法1</li> </ul> <pre><code class="prism language-python">sem<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">with</span> sem<span class="token punctuation">:</span><span class="token comment">#work with shared resourse</span></code></pre> <ul> <li>用法2</li> </ul> <pre><code class="prism language-python">sem<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>Semaphore<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token keyword">await</span> sem<span class="token punctuation">.</span>acquire<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span><span class="token punctuation">:</span><span class="token comment">#work with shared resourse</span><span class="token keyword">finally</span><span class="token punctuation">:</span> 	sem<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre> <h2><a id="await_178" rel="nofollow"></a>await关键字</h2> <p>根据官方文档说明，await 后面的对象必须是如下格式之一：</p> <ol> <li>A native coroutine object returned from a native coroutine function，一个原生 coroutine 对象。</li> <li>A generator-based coroutine object returned from a function decorated with types.coroutine()，一个由 types.coroutine() 修饰的生成器，这个生成器可以返回 coroutine 对象。</li> <li>An object with an await__ method returning an iterator，一个包含 __await 方法的对象返回的一个迭代器。</li> </ol> <p>简而言之，在await后面只能跟三种可等待的对象：<strong>协程对象、future对象、task对象</strong></p> <p>要实现异步处理，我们得先要有挂起的操作，当一个任务需要等待 IO 结果的时候，可以挂起当前任务，转而去执行其他任务，这样我们才能充分利用好资源。<strong>使用 await 可以将耗时等待的操作挂起，让出控制权。当协程执行的时候遇到 await，时间循环就会将本协程挂起，转而去执行别的协程，直到其他的协程挂起或执行完毕。</strong></p> <h2><a id="Task_193" rel="nofollow"></a>Task对象</h2> <p>tasks用于并发调度协程，它是对协程对象的进一步封装，包含了任务的各个状态。通过asyncio.creat_task(<strong>协程对象</strong>)的方式可以创建Task对象，这样可以让协程加入事件循环中等待被调度执行。除了使用asyncio.creat_task()以外，还可以用低层级的loop.creat_task()或asyncio.ensure_future()。<br /><strong>注意</strong>：asyncio.creat_task()在python3.7之后加入。在python3.7之前可以改用低层级的asyncio.ensure_future()或loop.create_task()（loop.create_task()是最低层级）。</p> <p><strong>例1：</strong></p> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> logging logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%(asctime)s - |%(levelname)s| - %(message)s'</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token string">'返回值'</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main start!'</span><span class="token punctuation">)</span>     task1<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     task2<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main end!'</span><span class="token punctuation">)</span>      r1<span class="token operator">=</span><span class="token keyword">await</span> task1     r2<span class="token operator">=</span><span class="token keyword">await</span> task2<span class="token keyword">print</span><span class="token punctuation">(</span>r1<span class="token punctuation">,</span>r2<span class="token punctuation">)</span>  asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <p>以上代码的输出为：<br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220818/a8bc5cc7f8e08e19c3ee7961fc88dde1.jpg" alt="python并发编程：协程asyncio、多线程threading、多进程multiprocessing"><br /> 代码的分析：<br /> 程序内部本质上只有一个线程，在main函数开始之后，到运行到r1 = await task1之前，线程都没有遇到io等待，所以会一瞬间将main函数中的前四行代码执行完毕。<br /> 此时算上asyncio.run(main())中注册的main()协程对象，加上task1、task2，相当于在事件循环中有三个任务。当遇到await的时候，会切换到别的任务中执行，所以在main()遇到await即r1 = await task1时，会切换到task1中执行任务，切换到task1中执行任务之后又遇到了io等待，所以又立即切换到了task2中去执行任务。<br /> 此时在控制台打印出的效果就是一瞬间实行了task1与task2，此时没有了io等待，所以程序等待task1与task2执行完毕后又回到main()中继续执行任务。</p> <p><strong>例2：将task放在一个列表中</strong></p> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> logging logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%(asctime)s - |%(levelname)s| - %(message)s'</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>x<span class="token punctuation">)</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token string-interpolation"><span class="token string">f'返回值</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main start!'</span><span class="token punctuation">)</span>     task_list<span class="token operator">=</span><span class="token punctuation">[</span>         asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'f1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>         asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'f2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'main end!'</span><span class="token punctuation">)</span><span class="token comment">#写法1，使用asyncio.wait</span><span class="token comment"># done,pending = await asyncio.wait(task_list,timeout = None)</span><span class="token comment"># print(done)</span><span class="token comment"># 此处打印的是一个Task finished对象的集合</span><span class="token comment">#写法2，使用asyncio.gather，asyncio.gather依照协程执行的先后顺序来返回一个列表</span><span class="token comment"># t = await asyncio.gather(*task_list)</span><span class="token comment"># print(t)</span><span class="token comment"># 此处打印：['返回值2', '返回值5']</span> asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <p><strong>例3：一种错误的写法</strong></p> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> logging logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%(asctime)s - |%(levelname)s| - %(message)s'</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">func</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span>x<span class="token punctuation">)</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">return</span><span class="token string-interpolation"><span class="token string">f'返回值</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>x<span class="token punctuation">}</span></span><span class="token string">'</span></span>  task_list<span class="token operator">=</span><span class="token punctuation">[</span>     asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'f1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     asyncio<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>func<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name<span class="token operator">=</span><span class="token string">'f2'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> done<span class="token punctuation">,</span> pending<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>asyncio<span class="token punctuation">.</span>wait<span class="token punctuation">(</span>task_list<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <p>这段代码会报错：<strong>no running event loop</strong><br /> 原因在于，使用asyncio.create_task的时候，事件循环还没有创建，所以会报错。<br /> 此时我们需要改写task_list成这样：</p> <pre><code class="prism language-python">task_list<span class="token operator">=</span><span class="token punctuation">[</span>     func<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>     func<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre> <p>在task_list里面放协程对象，而不是放task对象，改成这样就可以正常运行了。原因在于在asyncio.run的内部其实会帮你创建一个事件循环，然后这个事件循环中，你传进去的协程对象，它会在内部帮你创建成task对象，就解决了事件循环还没有创建而报错的问题。<br /> 建议还是按照例2的方式，将asyncio.creak_task放在一个main()的协程对象里就行了。</p> <h2><a id="Future_294" rel="nofollow"></a>Future对象</h2> <p><strong>Future</strong>：代表将来执行或没有执行的任务的结果，Future 相较于Task属于更底层的概念。Future，又称 未来对象、期程对象，其本质上是一个容器，用于接受异步执行的结果。<br /> Furture 对象内部封装了一个 _state，这个 _state 维护着四种状态：Pending、Running、Done，Cancelled，如果变成 Done 完成，就不再等待，而是往后执行，这四种状态的存在其实类似与进程的运行态、就绪态、阻塞态，事件循环凭借着四种状态对 Future\协程对象 进行调度。<br /> 我们前面讲的 Task 是继承自 Future，Task对象内部await结果的处理是基于Future对象来的。</p> <p><strong>例1</strong></p> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment"># 获取当前事件循环</span>     loop<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_event_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 创建一个任务(Future对象,这个任务什么都不干)</span>     fut<span class="token operator">=</span> loop<span class="token punctuation">.</span>create_future<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment"># 等待任务最终结果(Future对象),没有结果则会一直等下去</span><span class="token keyword">await</span> fut  asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <p>上面代码会一直运行，不会停止。</p> <p><strong>例2</strong></p> <pre><code class="prism language-python"><span class="token keyword">import</span> asyncio<span class="token keyword">import</span> logging logging<span class="token punctuation">.</span>basicConfig<span class="token punctuation">(</span>level<span class="token operator">=</span>logging<span class="token punctuation">.</span>INFO<span class="token punctuation">,</span><span class="token builtin">format</span><span class="token operator">=</span><span class="token string">'%(asctime)s - |%(levelname)s| - %(message)s'</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">set_after</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">:</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'enter set_after'</span><span class="token punctuation">)</span><span class="token keyword">await</span> asyncio<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>     fut<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span><span class="token string">'666'</span><span class="token punctuation">)</span><span class="token keyword">async</span><span class="token keyword">def</span><span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'enter main'</span><span class="token punctuation">)</span><span class="token comment">#获取当前时间循环</span>     loop<span class="token operator">=</span> asyncio<span class="token punctuation">.</span>get_running_loop<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#创建一个任务(Future对象),没绑定任何行为,则这个任务永远不知道什么时候结束</span>     fut<span class="token operator">=</span> loop<span class="token punctuation">.</span>create_future<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">#创建一个任务(Task对象),绑定了set_after函数,函数内部在2s之后会给fut赋值。即手动设置future任务的最终结果,那么fut就可结束了</span><span class="token keyword">await</span> loop<span class="token punctuation">.</span>create_task<span class="token punctuation">(</span>set_after<span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment">#此处分析一下是否加await的区别</span>      logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string">'get data'</span><span class="token punctuation">)</span><span class="token comment">#等待Future对象获取最终结果,否则一直等下去</span>     data<span class="token operator">=</span><span class="token keyword">await</span> fut     logging<span class="token punctuation">.</span>info<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token string">f'fut的返回值为</span><span class="token interpolation"><span class="token punctuation">{<!-- --></span>data<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>  asyncio<span class="token punctuation">.</span>run<span class="token punctuation">(</span>main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre> <p>上述代码中，在loop.create_task(set_after(fut))前加了await后的输出结果为:<br /><img decoding="async" src="http://img.555519.xyz/uploads3/20220818/a501ca2119aab4db24762b5c25658d70.jpg" alt="python并发编程：协程asyncio、多线程threading、多进程multiprocessing"><br /> 分析如下：<br /> 首先进入main()协程对象，打印enter_main，然后</p> <h2><a id="creak_taskensure_future_355" rel="nofollow"></a>creak_task与ensure_future的异同</h2> <h2><a id="asynciowaitasyniogather_357" rel="nofollow"></a>asyncio.wait与asynio.gather的异同</h2> <p>asynio.gather()中的参数可以是<strong>task</strong>或<strong>协程对象</strong>,并且得到其列表形式的返回值。其中如果传入的是协程对象，那么首先gather会先把这些协程对象转换为task，</p> <h2><a id="event_loop_360" rel="nofollow"></a>event loop</h2> <p>event loop相当于一个大脑，在下面有若干的task，task是没有办法去控制event loop去执行某一个task的，它只能告诉event loop说我在等这个task，最终是由event loop去决定下面要运行哪一个task。而event loop一旦开始运行task，就必须要task<strong>显式地</strong>把控制权交还给event loop，交还控制权的方式有<strong>await</strong>和<strong>函数运行完毕</strong>。所以尽管我们说协程的方式是并发的，但实际上同一时刻只有一段代码在运行，它只是想办法利用了代码中间等待的时间，所以如果我们的代码里面没有等待的话，协程的帮助并不大。</p> <h1><a id="_362" rel="nofollow"></a>参考文章</h1> <p><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.jianshu.com/p/ff2c7b7597aa"  rel="nofollow">Python：协程中Task和Future的理解及使用</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.cnblogs.com/Summer-skr--blog/p/11486634.html"  rel="nofollow">Python爬虫进阶、异步协程</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.bilibili.com/video/BV1dD4y127bD?p=8"  rel="nofollow">Python异步编程视频讲解</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.bilibili.com/video/BV1oa411b7c9"  rel="nofollow">【python】asyncio的理解与入门，搞不明白协程？看这个视频就够了。</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://www.bilibili.com/video/BV1bK411A7tV?p=1"  rel="nofollow">【2021最新版】Python 并发编程实战，用多线程、多进程、多协程加速程序运行</a><br /><a href="http://www.m6000.cn/wp-content/themes/begin%20lts/inc/go.php?url=https://zhuanlan.zhihu.com/p/59621713"  rel="nofollow">Python中协程异步IO（asyncio）详解</a></p> </div> 			                </div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/html/category/article-2438.htm">关于feign调用传递header的解决方法</a></p>
                                        <p>下一个：<a href="/html/category/article-2440.htm">如何使用–Recurse参数在PowerShell中复制文件夹内容？</a></p>
                                    </div>
                            </div>
            <div class="col-md-3">
                <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/html/category/article-2478.htm" title="Jackson忽略字段不序列化字段的3种方法">Jackson忽略字段不序列化字段的3种方法</a></li>
                        <li class="py-2"><a href="/html/category/article-2505.htm" title="SpringMvc注解@PathVariable">SpringMvc注解@PathVariable</a></li>
                        <li class="py-2"><a href="/html/category/article-2504.htm" title="全链路日志追踪系统介绍与思考">全链路日志追踪系统介绍与思考</a></li>
                        <li class="py-2"><a href="/html/category/article-2488.htm" title="一文搞定数据库连接池，太TM简单了，收藏！！！">一文搞定数据库连接池，太TM简单了，收藏！！！</a></li>
                        <li class="py-2"><a href="/html/category/article-2506.htm" title="JavaScript如何使用过滤器从数组中删除元素">JavaScript如何使用过滤器从数组中删除元素</a></li>
                        <li class="py-2"><a href="/html/category/article-2493.htm" title="FreeRTOS实时操作系统信号量基础_操作系统">FreeRTOS实时操作系统信号量基础_操作系统</a></li>
                        <li class="py-2"><a href="/html/category/article-2840.htm" title="MySQL 表数据多久刷一次盘">MySQL 表数据多久刷一次盘</a></li>
                        <li class="py-2"><a href="/html/category/article-2520.htm" title="Jav详细介绍的Mapper对应的Mybatis xml查询结果resultType返回值类型">Jav详细介绍的Mapper对应的Mybatis xml查询结果resultType返回值类型</a></li>
                        <li class="py-2"><a href="/html/category/article-2483.htm" title="setTimeout、Promise、Async/Await 的区别">setTimeout、Promise、Async/Await 的区别</a></li>
                        <li class="py-2"><a href="/html/category/article-2507.htm" title="防止重复提交拦截器 spring boot">防止重复提交拦截器 spring boot</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">52</span> <a href="/html/date/2024-06/" title="2024-06 归档">2024-06</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-05/" title="2024-05 归档">2024-05</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">60</span> <a href="/html/date/2024-04/" title="2024-04 归档">2024-04</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">62</span> <a href="/html/date/2024-03/" title="2024-03 归档">2024-03</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">44</span> <a href="/html/date/2024-02/" title="2024-02 归档">2024-02</a></h4>
            </li>
                    </ul>
    </div>
</div>

            </div>
        </div>
    </div>
    <!-- //single -->
    <!-- footer -->
	
	<div class="copy-right-social">
		<div class="container">
			<div class="footer-pos">
				<a href="#ban" class="scroll"><img src="/assets/addons/xcblog/img/pakistanaddress/arrow.png" alt=" " class="img-responsive" /></a>
			</div>
            <div class="col-lg-8 footer-left">
                <p class="m-0">Pakistan Address 版权所有</p>
            </div>
			<div class="copy-right-social1">
				<div class="w3l_social_icons w3l_social_icons1">
					<ul>
						<li><a href="#" class="facebook"></a></li>
						<li><a href="#" class="twitter"></a></li>
						<li><a href="#" class="google_plus"></a></li>
						<li><a href="#" class="pinterest"></a></li>
						<li><a href="#" class="instagram"></a></li>
					</ul>
				</div>
			</div>
			<div class="clearfix"> </div>
		</div>
	</div>
<!-- //footer -->
<!-- for bootstrap working -->
	<script src="/assets/addons/xcblog/js/frontend/pakistanaddress/bootstrap.js"></script>
    <script>
    $(function() {
        $('.js_to').click(function() {
            var url = $(this).data('url');
            var code = $(this).data('code');
            url += code;

            window.open(url);
        })
    });
    </script>
</body>

</html>